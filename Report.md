# Отчёт по лабораторной работе №2

Для выполгения лабораторной работы необходимо написать скрипт на bash, получающий на вход IPV4 адрес и переводящий его в двоичный вид.

Приведу весь код скрипта целиком, а затем приведу пояснения к отдельным его строкам:

```
#!/bin/bash

to_bin() {
    IFS='.' read -r -a octets <<< "$1"
    bin=""
    for octet in "${octets[@]}"; do
        bin+="$(printf "%08d" $(echo "obase=2;$octet" | bc))."
    done
    echo "${bin%?}"
}

if [ $# -eq 1 ]
then
    ipv4_ad=$1
    bin_ad=$(to_bin "$ipv4_ad")
    echo "$bin_ad"
else
    echo "Usage: $0 <IPv4 address>"
    exit 1
fi
```

Разберём функцию `to_bin()`

`IFS='.' read -r -a octets <<< "$1"`

`IFS='.'` разбивает строку на блоки, разделителем которых является точка(т.о. выделяются отдельные октеты)

`read -r -a octets`: Эта команда читает строку из стандартного ввода и разбивает её на слова, используя IFS в качестве разделителя. -r позволяет не интерпритировать обратные слеши  -a octets записывает всё в одноимённый массив.

`<<< "$1"` передаёт то, что напишет пользователь при вызове команды

`bin+="$(printf "%08d" $(echo "obase=2;$octet" | bc))."` на каждой итерации добавляет строке bin двоичное представление каждого октета, `"%08d"` гарантирует строку из 8 символов тем, что если их меньше, то в начале допишутся нули.

`echo "obase=2;$octet" | bc` переводит элемент массива в двоичный вид (`obase=2` задаёт основание 2)

Конструкция `if` проверяет, сколько аргументов передаёдтся. Если их больше одно, то программа завершится с ошибкой. если нет, то вызовется функция `to_bin`, принимая введённый адрес в качестве аргумента.